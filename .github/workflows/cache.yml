name: Advanced Caching Strategy

on:
  workflow_call:
    inputs:
      cache-key-prefix:
        description: 'Prefix for cache keys'
        required: false
        type: string
        default: 'yaml-formatter'
      go-version:
        description: 'Go version to use'
        required: false
        type: string
        default: '1.21'

# This workflow defines reusable caching strategies for the project

jobs:
  setup-cache:
    name: Setup Advanced Caching
    runs-on: ubuntu-latest
    outputs:
      cache-hit: ${{ steps.cache-go.outputs.cache-hit }}
      cache-key: ${{ steps.cache-key.outputs.key }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate cache key
        id: cache-key
        run: |
          # Create a composite cache key based on multiple factors
          go_mod_hash=$(sha256sum go.mod go.sum | sha256sum | cut -d' ' -f1)
          week=$(date +%U)
          echo "key=${{ inputs.cache-key-prefix }}-${{ inputs.go-version }}-${go_mod_hash}-week${week}" >> $GITHUB_OUTPUT
          echo "fallback-key=${{ inputs.cache-key-prefix }}-${{ inputs.go-version }}-${go_mod_hash}" >> $GITHUB_OUTPUT

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ inputs.go-version }}
          cache: false # We handle caching manually for better control

      - name: Cache Go modules and build cache
        id: cache-go
        uses: actions/cache@v3
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
            /tmp/go-build-cache
          key: ${{ steps.cache-key.outputs.key }}
          restore-keys: |
            ${{ steps.cache-key.outputs.fallback-key }}
            ${{ inputs.cache-key-prefix }}-${{ inputs.go-version }}-
            ${{ inputs.cache-key-prefix }}-

      - name: Cache test data
        uses: actions/cache@v3
        with:
          path: |
            testdata/optimized/
            /tmp/yaml-formatter-cache/
          key: testdata-${{ hashFiles('testdata/**/*') }}
          restore-keys: testdata-

      - name: Cache golangci-lint
        uses: actions/cache@v3
        with:
          path: ~/.cache/golangci-lint
          key: golangci-lint-${{ runner.os }}-${{ hashFiles('.golangci.yml') }}
          restore-keys: golangci-lint-${{ runner.os }}-

      - name: Pre-warm Go module cache
        if: steps.cache-go.outputs.cache-hit != 'true'
        run: |
          go mod download
          go mod verify

      - name: Pre-warm build cache
        if: steps.cache-go.outputs.cache-hit != 'true'
        run: |
          # Build once to populate build cache
          go build -v ./...
          # Run tests once to cache test dependencies
          go test -v -run=^$ ./... || true

  # Cache management job for cleanup
  cache-management:
    name: Cache Management
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ inputs.go-version }}

      - name: Clean old caches
        run: |
          # This would typically involve calling GitHub API to clean old caches
          # For now, we'll just log the action
          echo "Cache cleanup would be performed here"
          echo "Current cache strategy: Weekly rotation with fallbacks"

      - name: Generate cache statistics
        run: |
          echo "## Cache Statistics" >> $GITHUB_STEP_SUMMARY
          echo "- Cache prefix: ${{ inputs.cache-key-prefix }}" >> $GITHUB_STEP_SUMMARY
          echo "- Go version: ${{ inputs.go-version }}" >> $GITHUB_STEP_SUMMARY
          echo "- Go modules hash: $(sha256sum go.mod go.sum | sha256sum | cut -d' ' -f1)" >> $GITHUB_STEP_SUMMARY
          echo "- Week number: $(date +%U)" >> $GITHUB_STEP_SUMMARY
          echo "- Cache strategy: Multi-level with weekly rotation" >> $GITHUB_STEP_SUMMARY

# Advanced caching strategies
cache-strategies:
  # Strategy 1: Layered caching
  layered-cache:
    name: Layered Cache Strategy
    runs-on: ubuntu-latest
    steps:
      - name: Layer 1 - Go installation
        uses: actions/cache@v3
        with:
          path: /opt/hostedtoolcache/go
          key: go-installation-${{ runner.os }}-${{ inputs.go-version }}

      - name: Layer 2 - Go modules
        uses: actions/cache@v3
        with:
          path: ~/go/pkg/mod
          key: go-modules-${{ hashFiles('go.sum') }}
          restore-keys: go-modules-

      - name: Layer 3 - Build cache
        uses: actions/cache@v3
        with:
          path: ~/.cache/go-build
          key: go-build-${{ runner.os }}-${{ hashFiles('**/*.go') }}
          restore-keys: |
            go-build-${{ runner.os }}-
            go-build-

      - name: Layer 4 - Test cache
        uses: actions/cache@v3
        with:
          path: /tmp/test-cache
          key: test-cache-${{ hashFiles('**/*_test.go') }}
          restore-keys: test-cache-

  # Strategy 2: Dependency-aware caching
  dependency-cache:
    name: Dependency-Aware Cache
    runs-on: ubuntu-latest
    steps:
      - name: Analyze dependencies
        run: |
          # Generate dependency graph hash for more precise caching
          go mod graph | sort | sha256sum > /tmp/dep-graph-hash

      - name: Cache by dependency graph
        uses: actions/cache@v3
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          key: deps-${{ hashFiles('/tmp/dep-graph-hash') }}
          restore-keys: deps-

  # Strategy 3: Parallel cache loading
  parallel-cache:
    name: Parallel Cache Loading
    runs-on: ubuntu-latest
    steps:
      - name: Load caches in parallel
        uses: actions/cache@v3
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
            ~/.cache/golangci-lint
            testdata/optimized/
          key: parallel-${{ hashFiles('go.sum', '.golangci.yml', 'testdata/**/*') }}
          restore-keys: |
            parallel-${{ hashFiles('go.sum', '.golangci.yml') }}
            parallel-${{ hashFiles('go.sum') }}
            parallel-

# Cache warming job for nightly builds
  cache-warming:
    name: Cache Warming
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    strategy:
      matrix:
        go-version: ['1.20', '1.21', '1.22']
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go ${{ matrix.go-version }}
        uses: actions/setup-go@v4
        with:
          go-version: ${{ matrix.go-version }}

      - name: Warm up cache
        run: |
          go mod download
          go build -v ./...
          go test -v -run=^$ ./...

      - name: Cache Go modules for ${{ matrix.go-version }}
        uses: actions/cache@v3
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          key: warm-${{ matrix.go-version }}-${{ hashFiles('go.sum') }}

# Cache monitoring
  cache-monitoring:
    name: Cache Monitoring
    runs-on: ubuntu-latest
    if: always()
    needs: [setup-cache]
    steps:
      - name: Monitor cache performance
        run: |
          echo "## Cache Performance Report" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ needs.setup-cache.outputs.cache-hit }}" == "true" ]]; then
            echo "âœ… Cache hit successful for key: ${{ needs.setup-cache.outputs.cache-key }}" >> $GITHUB_STEP_SUMMARY
            echo "âš¡ Estimated time saved: 2-5 minutes" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ Cache miss for key: ${{ needs.setup-cache.outputs.cache-key }}" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ”„ Cache will be populated for future runs" >> $GITHUB_STEP_SUMMARY
          fi
          echo "ðŸ“Š Cache strategy: Multi-layered with weekly rotation" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŽ¯ Cache efficiency target: >80% hit rate" >> $GITHUB_STEP_SUMMARY